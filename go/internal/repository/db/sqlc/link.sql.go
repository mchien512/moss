// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: link.sql

package sqlc

import (
	"context"
)

const countLinksBySource = `-- name: CountLinksBySource :one
SELECT COUNT(*) AS count
FROM entry_links
WHERE source_entry_id = $1
`

// 5. Count how many outgoing links a given entry has
// (useful for setting “link_count” in your proto if you want outgoing count)
func (q *Queries) CountLinksBySource(ctx context.Context, sourceEntryID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLinksBySource, sourceEntryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLinksByTarget = `-- name: CountLinksByTarget :one
SELECT COUNT(*) AS count
FROM entry_links
WHERE target_entry_id = $1
`

// 6. Count how many incoming links a given entry has
// (useful for backlink counts)
func (q *Queries) CountLinksByTarget(ctx context.Context, targetEntryID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLinksByTarget, targetEntryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEntryLink = `-- name: CreateEntryLink :one

INSERT INTO entry_links (
    source_entry_id,
    target_entry_id,
    user_id,
    created_at
) VALUES (
             $1,  -- source_entry_id
             $2,  -- target_entry_id
             $3,  -- user_id (who created/owns this link)
             CURRENT_TIMESTAMP
         )
RETURNING source_entry_id, target_entry_id, user_id, created_at
`

type CreateEntryLinkParams struct {
	SourceEntryID string `json:"source_entry_id"`
	TargetEntryID string `json:"target_entry_id"`
	UserID        string `json:"user_id"`
}

// go/internal/link/repository/db/queries/entry_links.sql
// 1. Insert a new link between two entries
// Returns the inserted row (so SQLC can map it to an EntryLink struct).
func (q *Queries) CreateEntryLink(ctx context.Context, arg CreateEntryLinkParams) (EntryLink, error) {
	row := q.db.QueryRowContext(ctx, createEntryLink, arg.SourceEntryID, arg.TargetEntryID, arg.UserID)
	var i EntryLink
	err := row.Scan(
		&i.SourceEntryID,
		&i.TargetEntryID,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEntryLink = `-- name: DeleteEntryLink :exec
DELETE FROM entry_links
WHERE source_entry_id = $1
  AND target_entry_id = $2
`

type DeleteEntryLinkParams struct {
	SourceEntryID string `json:"source_entry_id"`
	TargetEntryID string `json:"target_entry_id"`
}

// 2. Delete a link (unlink two entries)
func (q *Queries) DeleteEntryLink(ctx context.Context, arg DeleteEntryLinkParams) error {
	_, err := q.db.ExecContext(ctx, deleteEntryLink, arg.SourceEntryID, arg.TargetEntryID)
	return err
}

const listBacklinkedEntries = `-- name: ListBacklinkedEntries :many

SELECT
    e.id,
    e.user_id,
    e.title,
    e.content,
    e.growth_stage,
    e.created_at,
    e.updated_at
FROM entries AS e
         JOIN entry_links AS l
              ON l.source_entry_id = e.id
WHERE l.target_entry_id = $1
ORDER BY e.created_at
LIMIT $2      -- page_size
    OFFSET $3
`

type ListBacklinkedEntriesParams struct {
	TargetEntryID string `json:"target_entry_id"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

// offset (page_token converted to integer)
//  8. (Optional) List the actual Entry rows that link *into* a given entry,
//     with pagination. Adjust as above.
func (q *Queries) ListBacklinkedEntries(ctx context.Context, arg ListBacklinkedEntriesParams) ([]Entry, error) {
	rows, err := q.db.QueryContext(ctx, listBacklinkedEntries, arg.TargetEntryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.GrowthStage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkedEntries = `-- name: ListLinkedEntries :many
SELECT
    e.id,
    e.user_id,
    e.title,
    e.content,
    e.growth_stage,
    e.created_at,
    e.updated_at
FROM entries AS e
         JOIN entry_links AS l
              ON l.target_entry_id = e.id
WHERE l.source_entry_id = $1
ORDER BY e.created_at
LIMIT $2      -- page_size
    OFFSET $3
`

type ListLinkedEntriesParams struct {
	SourceEntryID string `json:"source_entry_id"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

//  7. (Optional) List the actual Entry rows that a given source is linked to,
//     with pagination parameters (page size + offset). This is if you want to
//     fetch full Entry data in one go. Adjust the SELECT columns as needed.
func (q *Queries) ListLinkedEntries(ctx context.Context, arg ListLinkedEntriesParams) ([]Entry, error) {
	rows, err := q.db.QueryContext(ctx, listLinkedEntries, arg.SourceEntryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.GrowthStage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinksBySource = `-- name: ListLinksBySource :many
SELECT
    source_entry_id,
    target_entry_id,
    user_id,
    created_at
FROM entry_links
WHERE source_entry_id = $1
ORDER BY created_at
`

// 3. List all links where a given entry is the “source”
// (i.e. all outgoing links from entry X)
func (q *Queries) ListLinksBySource(ctx context.Context, sourceEntryID string) ([]EntryLink, error) {
	rows, err := q.db.QueryContext(ctx, listLinksBySource, sourceEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EntryLink
	for rows.Next() {
		var i EntryLink
		if err := rows.Scan(
			&i.SourceEntryID,
			&i.TargetEntryID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinksByTarget = `-- name: ListLinksByTarget :many
SELECT
    source_entry_id,
    target_entry_id,
    user_id,
    created_at
FROM entry_links
WHERE target_entry_id = $1
ORDER BY created_at
`

// 4. List all links where a given entry is the “target”
// (i.e. all incoming/backlinks to entry X)
func (q *Queries) ListLinksByTarget(ctx context.Context, targetEntryID string) ([]EntryLink, error) {
	rows, err := q.db.QueryContext(ctx, listLinksByTarget, targetEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EntryLink
	for rows.Next() {
		var i EntryLink
		if err := rows.Scan(
			&i.SourceEntryID,
			&i.TargetEntryID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
